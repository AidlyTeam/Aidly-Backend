// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: users.sql

package repo

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const changeUserRole = `-- name: ChangeUserRole :exec
UPDATE
    t_users
SET
    role_id = COALESCE($1, role_id)
WHERE
    id = $2
`

type ChangeUserRoleParams struct {
	RoleID uuid.UUID
	UserID uuid.UUID
}

func (q *Queries) ChangeUserRole(ctx context.Context, arg ChangeUserRoleParams) error {
	_, err := q.db.ExecContext(ctx, changeUserRole, arg.RoleID, arg.UserID)
	return err
}

const countUserByWalletAddress = `-- name: CountUserByWalletAddress :one
SELECT COUNT(*) 
FROM t_users 
WHERE wallet_address = $1
`

func (q *Queries) CountUserByWalletAddress(ctx context.Context, walletAddress string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUserByWalletAddress, walletAddress)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO t_users 
    (role_id, name, surname, wallet_address, is_default, created_at)
VALUES 
    ($1, $2, $3, $4, $5, NOW())
RETURNING id
`

type CreateUserParams struct {
	RoleID        uuid.UUID
	Name          sql.NullString
	Surname       sql.NullString
	WalletAddress string
	IsDefault     bool
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.RoleID,
		arg.Name,
		arg.Surname,
		arg.WalletAddress,
		arg.IsDefault,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM 
    t_users
WHERE
    id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteUser, userID)
	return err
}

const getDefaultUser = `-- name: GetDefaultUser :one
SELECT 
    id, role_id, wallet_address, name, surname, is_default, created_at
FROM 
    t_users 
WHERE 
    is_default = true
`

func (q *Queries) GetDefaultUser(ctx context.Context) (TUser, error) {
	row := q.db.QueryRowContext(ctx, getDefaultUser)
	var i TUser
	err := row.Scan(
		&i.ID,
		&i.RoleID,
		&i.WalletAddress,
		&i.Name,
		&i.Surname,
		&i.IsDefault,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT 
    id, role_id, wallet_address, name, surname, is_default, created_at
FROM 
    t_users
WHERE 
    id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, userID uuid.UUID) (TUser, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, userID)
	var i TUser
	err := row.Scan(
		&i.ID,
		&i.RoleID,
		&i.WalletAddress,
		&i.Name,
		&i.Surname,
		&i.IsDefault,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByWalletAddress = `-- name: GetUserByWalletAddress :one
SELECT 
    id, role_id, wallet_address, name, surname, is_default, created_at
FROM 
    t_users 
WHERE 
    wallet_address = $1
`

func (q *Queries) GetUserByWalletAddress(ctx context.Context, walletAddress string) (TUser, error) {
	row := q.db.QueryRowContext(ctx, getUserByWalletAddress, walletAddress)
	var i TUser
	err := row.Scan(
		&i.ID,
		&i.RoleID,
		&i.WalletAddress,
		&i.Name,
		&i.Surname,
		&i.IsDefault,
		&i.CreatedAt,
	)
	return i, err
}

const getUsers = `-- name: GetUsers :many
SELECT 
    id, role_id, wallet_address, name, surname, is_default, created_at
FROM 
    t_users
WHERE
    ($1 IS NULL OR id = $1) AND
    ($2 IS NULL OR wallet_address = $2)
LIMIT $4 OFFSET $3
`

type GetUsersParams struct {
	ID            interface{}
	WalletAddress interface{}
	Off           int32
	Lim           int32
}

func (q *Queries) GetUsers(ctx context.Context, arg GetUsersParams) ([]TUser, error) {
	rows, err := q.db.QueryContext(ctx, getUsers,
		arg.ID,
		arg.WalletAddress,
		arg.Off,
		arg.Lim,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TUser
	for rows.Next() {
		var i TUser
		if err := rows.Scan(
			&i.ID,
			&i.RoleID,
			&i.WalletAddress,
			&i.Name,
			&i.Surname,
			&i.IsDefault,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isDefaultUserExists = `-- name: IsDefaultUserExists :one
SELECT 
    EXISTS (
        SELECT 1 
        FROM t_users u
        WHERE u.is_default = true
    ) AS is_default_user_exists
`

func (q *Queries) IsDefaultUserExists(ctx context.Context) (bool, error) {
	row := q.db.QueryRowContext(ctx, isDefaultUserExists)
	var is_default_user_exists bool
	err := row.Scan(&is_default_user_exists)
	return is_default_user_exists, err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE
    t_users
SET
    name = COALESCE($1, name),
    surname = COALESCE($2, surname)
WHERE
    id = $3
`

type UpdateUserParams struct {
	Name    sql.NullString
	Surname sql.NullString
	UserID  uuid.UUID
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.ExecContext(ctx, updateUser, arg.Name, arg.Surname, arg.UserID)
	return err
}
