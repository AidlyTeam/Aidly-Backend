// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: userBadgets.sql

package repo

import (
	"context"

	"github.com/google/uuid"
)

const addUserBadge = `-- name: AddUserBadge :one
INSERT INTO t_user_badges 
    (user_id, badge_id)
VALUES 
    ($1, $2)
RETURNING id
`

type AddUserBadgeParams struct {
	UserID  uuid.UUID
	BadgeID uuid.UUID
}

func (q *Queries) AddUserBadge(ctx context.Context, arg AddUserBadgeParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, addUserBadge, arg.UserID, arg.BadgeID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const countUserBadge = `-- name: CountUserBadge :one
SELECT
    COUNT(*)
FROM
    t_user_badges
WHERE
    user_id = $1
`

func (q *Queries) CountUserBadge(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUserBadge, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUserBadgeExists = `-- name: GetUserBadgeExists :one
SELECT 
    EXISTS (
        SELECT 1 
        FROM t_user_badges 
        WHERE user_id = $1 AND badge_id = $2
    ) AS exists
`

type GetUserBadgeExistsParams struct {
	UserID  uuid.UUID
	BadgeID uuid.UUID
}

func (q *Queries) GetUserBadgeExists(ctx context.Context, arg GetUserBadgeExistsParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, getUserBadgeExists, arg.UserID, arg.BadgeID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getUserBadges = `-- name: GetUserBadges :many
SELECT 
    b.id, b.name, b.description, b.icon_path, b.donation_threshold, b.created_at
FROM 
    t_user_badges ub
JOIN 
    t_badges b ON ub.badge_id = b.id
WHERE 
    ub.user_id = $1
`

func (q *Queries) GetUserBadges(ctx context.Context, userID uuid.UUID) ([]TBadge, error) {
	rows, err := q.db.QueryContext(ctx, getUserBadges, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TBadge
	for rows.Next() {
		var i TBadge
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.IconPath,
			&i.DonationThreshold,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeUserBadge = `-- name: RemoveUserBadge :exec
DELETE FROM 
    t_user_badges
WHERE 
    user_id = $1 AND badge_id = $2
`

type RemoveUserBadgeParams struct {
	UserID  uuid.UUID
	BadgeID uuid.UUID
}

func (q *Queries) RemoveUserBadge(ctx context.Context, arg RemoveUserBadgeParams) error {
	_, err := q.db.ExecContext(ctx, removeUserBadge, arg.UserID, arg.BadgeID)
	return err
}
