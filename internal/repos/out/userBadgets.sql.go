// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: userBadgets.sql

package repo

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const addUserBadge = `-- name: AddUserBadge :one
INSERT INTO t_user_badges 
    (user_id, badge_id)
VALUES 
    ($1, $2)
RETURNING id
`

type AddUserBadgeParams struct {
	UserID  uuid.UUID
	BadgeID uuid.UUID
}

func (q *Queries) AddUserBadge(ctx context.Context, arg AddUserBadgeParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, addUserBadge, arg.UserID, arg.BadgeID)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const changeIsMinted = `-- name: ChangeIsMinted :exec
UPDATE
    t_user_badges
SET
    is_minted = COALESCE(TRUE, is_minted)
WHERE
    user_id = $1 AND badge_id = $2
`

type ChangeIsMintedParams struct {
	UserID  uuid.UUID
	BadgeID uuid.UUID
}

func (q *Queries) ChangeIsMinted(ctx context.Context, arg ChangeIsMintedParams) error {
	_, err := q.db.ExecContext(ctx, changeIsMinted, arg.UserID, arg.BadgeID)
	return err
}

const countUserBadge = `-- name: CountUserBadge :one
SELECT
    COUNT(*)
FROM
    t_user_badges
WHERE
    user_id = $1
`

func (q *Queries) CountUserBadge(ctx context.Context, userID uuid.UUID) (int64, error) {
	row := q.db.QueryRowContext(ctx, countUserBadge, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUserBadge = `-- name: GetUserBadge :one
SELECT 
    b.id, b.symbol, b.name, b.description, b.seller_fee, b.icon_path, b.donation_threshold, b.uri, b.is_nft, ub.is_minted, b.created_at
FROM 
    t_user_badges ub
JOIN 
    t_badges b ON ub.badge_id = b.id
WHERE 
    ub.user_id = $1 AND
    b.id = $2
`

type GetUserBadgeParams struct {
	UserID  uuid.UUID
	BadgeID uuid.UUID
}

type GetUserBadgeRow struct {
	ID                uuid.UUID
	Symbol            sql.NullString
	Name              string
	Description       sql.NullString
	SellerFee         sql.NullInt32
	IconPath          sql.NullString
	DonationThreshold int32
	Uri               sql.NullString
	IsNft             bool
	IsMinted          bool
	CreatedAt         sql.NullTime
}

func (q *Queries) GetUserBadge(ctx context.Context, arg GetUserBadgeParams) (GetUserBadgeRow, error) {
	row := q.db.QueryRowContext(ctx, getUserBadge, arg.UserID, arg.BadgeID)
	var i GetUserBadgeRow
	err := row.Scan(
		&i.ID,
		&i.Symbol,
		&i.Name,
		&i.Description,
		&i.SellerFee,
		&i.IconPath,
		&i.DonationThreshold,
		&i.Uri,
		&i.IsNft,
		&i.IsMinted,
		&i.CreatedAt,
	)
	return i, err
}

const getUserBadgeExists = `-- name: GetUserBadgeExists :one
SELECT 
    EXISTS (
        SELECT 1 
        FROM t_user_badges 
        WHERE user_id = $1 AND badge_id = $2
    ) AS exists
`

type GetUserBadgeExistsParams struct {
	UserID  uuid.UUID
	BadgeID uuid.UUID
}

func (q *Queries) GetUserBadgeExists(ctx context.Context, arg GetUserBadgeExistsParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, getUserBadgeExists, arg.UserID, arg.BadgeID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const getUserBadges = `-- name: GetUserBadges :many
SELECT 
    b.id, b.symbol, b.name, b.description, b.seller_fee, b.icon_path, b.donation_threshold, b.uri, b.is_nft, ub.is_minted, b.created_at
FROM 
    t_user_badges ub
JOIN 
    t_badges b ON ub.badge_id = b.id
WHERE 
    ub.user_id = $1
`

type GetUserBadgesRow struct {
	ID                uuid.UUID
	Symbol            sql.NullString
	Name              string
	Description       sql.NullString
	SellerFee         sql.NullInt32
	IconPath          sql.NullString
	DonationThreshold int32
	Uri               sql.NullString
	IsNft             bool
	IsMinted          bool
	CreatedAt         sql.NullTime
}

func (q *Queries) GetUserBadges(ctx context.Context, userID uuid.UUID) ([]GetUserBadgesRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserBadges, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserBadgesRow
	for rows.Next() {
		var i GetUserBadgesRow
		if err := rows.Scan(
			&i.ID,
			&i.Symbol,
			&i.Name,
			&i.Description,
			&i.SellerFee,
			&i.IconPath,
			&i.DonationThreshold,
			&i.Uri,
			&i.IsNft,
			&i.IsMinted,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeUserBadge = `-- name: RemoveUserBadge :exec
DELETE FROM 
    t_user_badges
WHERE 
    user_id = $1 AND badge_id = $2
`

type RemoveUserBadgeParams struct {
	UserID  uuid.UUID
	BadgeID uuid.UUID
}

func (q *Queries) RemoveUserBadge(ctx context.Context, arg RemoveUserBadgeParams) error {
	_, err := q.db.ExecContext(ctx, removeUserBadge, arg.UserID, arg.BadgeID)
	return err
}
